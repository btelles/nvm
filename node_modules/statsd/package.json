{
  "name": "statsd",
  "description": "A simple, lightweight network daemon to collect metrics over UDP",
  "author": {
    "name": "Etsy"
  },
  "scripts": {
    "test": "./run_tests.sh"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/etsy/statsd.git"
  },
  "version": "0.5.0",
  "dependencies": {
    "node-syslog": "1.1.3"
  },
  "devDependencies": {
    "nodeunit": "0.6.x",
    "async": "0.1.x",
    "underscore": "1.2.x",
    "temp": "0.4.x"
  },
  "optionalDependencies": {
    "node-syslog": "1.1.3"
  },
  "engine": {
    "node": ">=0.4"
  },
  "bin": {
    "statsd": "./bin/statsd"
  },
  "readme": "StatsD [![Build Status](https://secure.travis-ci.org/etsy/statsd.png)](http://travis-ci.org/etsy/statsd)\n======\n\nA network daemon that runs on the [Node.js][node] platform and\nlistens for statistics, like counters and timers, sent over [UDP][udp]\nand sends aggregates to one or more pluggable backend services (e.g.,\n[Graphite][graphite]).\n\nWe ([Etsy][etsy]) [blogged][blog post] about how it works and why we created it.\n\n\nConcepts\n--------\n\n* *buckets*\n  Each stat is in its own \"bucket\". They are not predefined anywhere. Buckets can be named anything that will translate to Graphite (periods make folders, etc)\n\n* *values*\n  Each stat will have a value. How it is interpreted depends on modifiers. In\ngeneral values should be integer.\n\n* *flush*\n  After the flush interval timeout (default 10 seconds), stats are\n  aggregated and sent to an upstream backend service.\n\nCounting\n--------\n\n    gorets:1|c\n\nThis is a simple counter. Add 1 to the \"gorets\" bucket. It stays in memory until the flush interval `config.flushInterval`.\n\n\nTiming\n------\n\n    glork:320|ms\n\nThe glork took 320ms to complete this time. StatsD figures out 90th percentile,\naverage (mean), lower and upper bounds for the flush interval.  The percentile\nthreshold can be tweaked with `config.percentThreshold`.\n\nThe percentile threshold can be a single value, or a list of values, and will\ngenerate the following list of stats for each threshold:\n\n    stats.timers.$KEY.mean_$PCT stats.timers.$KEY.upper_$PCT\n\nWhere `$KEY` is the key you stats key you specify when sending to statsd, and\n`$PCT` is the percentile threshold.\n\nSampling\n--------\n\n    gorets:1|c|@0.1\n\nTells StatsD that this counter is being sent sampled every 1/10th of the time.\n\nGauges\n------\nStatsD now also supports gauges, arbitrary values, which can be recorded.\n\n    gaugor:333|g\n\nAll metrics can also be batch send in a single UDP packet, separated by a\nnewline character.\n\nDebugging\n---------\n\nThere are additional config variables available for debugging:\n\n* `debug` - log exceptions and periodically print out information on counters and timers\n* `debugInterval` - interval for printing out information on counters and timers\n* `dumpMessages` - print debug info on incoming messages\n\nFor more information, check the `exampleConfig.js`.\n\nSupported Backends\n------------------\n\nStatsD supports multiple, pluggable, backend modules that can publish\nstatistics from the local StatsD daemon to a backend service or data\nstore. Backend services can retain statistics for\nlonger durations in a time series data store, visualize statistics in\ngraphs or tables, or generate alerts based on defined thresholds. A\nbackend can also correlate statistics sent from StatsD daemons running\nacross multiple hosts in an infrastructure.\n\nStatsD includes the following backends:\n\n* [Graphite][graphite] (`graphite`): Graphite is an open-source\n  time-series data store that provides visualization through a\n  web-browser interface.\n* Console (`console`): The console backend outputs the received\n  metrics to stdout (e.g. for seeing what's going on during development).\n\nBy default, the `graphite` backend will be loaded automatically. To\nselect which backends are loaded, set the `backends` configuration\nvariable to the list of backend modules to load.\n\nBackends are just npm modules which implement the interface described in\nsection *Backend Interface*. In order to be able to load the backend, add the\nmodule name into the `backends` variable in your config. As the name is also\nused in the `require` directive, you can load one of the provided backends by\ngiving the relative path (e.g. `./backends/graphite`).\n\nGraphite Schema\n---------------\n\nGraphite uses \"schemas\" to define the different round robin datasets it houses (analogous to RRAs in rrdtool). Here's an example for the stats databases:\n\nIn conf/storage-schemas.conf:\n \n    [stats]\n    pattern = ^stats\\..*\n    retentions = 10:2160,60:10080,600:262974\n\nIn conf/storage-aggregation.conf: \n\n    [min]\n    pattern = \\.min$\n    xFilesFactor = 0.1 \n    aggregationMethod = min \n\n    [max]\n    pattern = \\.max$\n    xFilesFactor = 0.1 \n    aggregationMethod = max \n\n    [sum]\n    pattern = \\.count$\n    xFilesFactor = 0 \n    aggregationMethod = sum \n\n    [default_average]\n    pattern = .*\n    xFilesFactor = 0.3 \n    aggregationMethod = average\n\nThis translates to:\n\n* 6 hours of 10 second data (what we consider \"near-realtime\")\n* 1 week of 1 minute data\n* 5 years of 10 minute data\n* For databases with 'min' or 'max' in the name, keep only the minimum and maximum value when rolling up data and store a None if less than 10% of the datapoints were received\n* For databases with 'count' in the name, add all the values together, and store only a None if none of the datapoints were received\n* For all other databases, average the values (mean) when rolling up data, and store a None if less than 30% of the datapoints were received \n\n(Note: Newer versions of Graphite can take human readable time formats like 10s:6h,1min:7d,10min:5y)\n\nRetentions and aggregations are read from the file in order, the first pattern that matches is used.  This is set when the database is first created, changing these config files will not change databases that have already been created.  To view or alter the settings on existing files, use whisper-info.py and whisper-resize.py included with the Whisper package. \n\nThese settings have been a good tradeoff so far between size-of-file (round robin databases are fixed size) and data we care about. Each \"stats\" database is about 3.2 megs with these retentions.  \n\nMany users have been confused to see their hit counts averaged, missing when the data is intermittent, or never stored when statsd is sending at a different interval than graphite expects.  Storage aggregation settings will help you control this and understand what Graphite is doing internally with your data. \n\nTCP Stats Interface\n-------------------\n\nA really simple TCP management interface is available by default on port 8126 or overriden in the configuration file. Inspired by the memcache stats approach this can be used to monitor a live statsd server.  You can interact with the management server by telnetting to port 8126, the following commands are available:\n\n* stats - some stats about the running server\n* counters - a dump of all the current counters\n* timers - a dump of the current timers\n\nThe stats output currently will give you:\n\n* uptime: the number of seconds elapsed since statsd started\n* messages.last_msg_seen: the number of elapsed seconds since statsd received a message\n* messages.bad_lines_seen: the number of bad lines seen since startup\n\nEach backend will also publish a set of statistics, prefixed by its\nmodule name.\n\nGraphite:\n\n* graphite.last_flush: the number of seconds elapsed since the last successful flush to graphite\n* graphite.last_exception: the number of seconds elapsed since the last exception thrown whilst flushing to graphite\n\nA simple nagios check can be found in the utils/ directory that can be used to check metric thresholds, for example the number of seconds since the last successful flush to graphite.\n\nInstallation and Configuration\n------------------------------\n\n * Install node.js\n * Clone the project\n * Create a config file from exampleConfig.js and put it somewhere\n * Start the Daemon:\n\n    node stats.js /path/to/config\n\nTests\n-----\n\nA test framework has been added using node-unit and some custom code to start and manipulate statsd. Please add tests under test/ for any new features or bug fixes encountered. Testing a live server can be tricky, attempts were made to eliminate race conditions but it may be possible to encounter a stuck state. If doing dev work, a `killall node` will kill any stray test servers in the background (don't do this on a production machine!).\n\nTests can be executd with `./run_tests.sh`.\n\nBackend Interface\n-----------------\n\nBackend modules are Node.js [modules][nodemods] that listen for a\nnumber of events emitted from StatsD. Each backend module should\nexport the following initialization function:\n\n* `init(startup_time, config, events)`: This method is invoked from StatsD to\n  initialize the backend module. It accepts three parameters:\n  `startup_time` is the startup time of StatsD in epoch seconds,\n  `config` is the parsed config file hash, and `events` is the event\n  emitter that backends can use to listen for events.\n\n  The backend module should return `true` from init() to indicate\n  success. A return of `false` indicates a failure to load the module\n  (missing configuration?) and will cause StatsD to exit.\n\nBackends can listen for the following events emitted by StatsD from\nthe `events` object:\n\n* Event: **'flush'**\n\n  Parameters: `(time_stamp, metrics)`\n\n  Emitted on each flush interval so that backends can push aggregate\n  metrics to their respective backend services. The event is passed\n  two parameters: `time_stamp` is the current time in epoch seconds\n  and `metrics` is a hash representing the StatsD statistics:\n\n  ```\nmetrics: {\n    counters: counters,\n    gauges: gauges,\n    timers: timers,\n    pctThreshold: pctThreshold\n}\n  ```\n\n  Each backend module is passed the same set of statistics, so a\n  backend module should treat the metrics as immutable\n  structures. StatsD will reset timers and counters after each\n  listener has handled the event.\n\n* Event: **'status'**\n\n  Parameters: `(writeCb)`\n\n  Emitted when a user invokes a *stats* command on the management\n  server port. It allows each backend module to dump backend-specific\n  status statistics to the management port.\n\n  The `writeCb` callback function has a signature of `f(error,\n  backend_name, stat_name, stat_value)`. The backend module should\n  invoke this method with each stat_name and stat_value that should be\n  sent to the management port. StatsD will prefix each stat name with\n  the `backend_name`. The backend should set `error` to *null*, or, in\n  the case of a failure, an appropriate error.\n\nInspiration\n-----------\n\nStatsD was inspired (heavily) by the project (of the same name) at Flickr. Here's a post where Cal Henderson described it in depth:\n[Counting and timing](http://code.flickr.com/blog/2008/10/27/counting-timing/). Cal re-released the code recently: [Perl StatsD](https://github.com/iamcal/Flickr-StatsD)\n\nMeta\n---------\n- IRC channel: `#statsd` on freenode\n- Mailing list: `statsd@librelist.com`\n\n\nContribute\n---------------------\n\nYou're interested in contributing to StatsD? *AWESOME*. Here are the basic steps:\n\nfork StatsD from here: http://github.com/etsy/statsd\n\n1. Clone your fork\n2. Hack away\n3. If you are adding new functionality, document it in the README\n4. If necessary, rebase your commits into logical chunks, without errors\n5. Push the branch up to GitHub\n6. Send a pull request to the etsy/statsd project.\n\nWe'll do our best to get your changes in!\n\n\n[graphite]: http://graphite.wikidot.com\n[etsy]: http://www.etsy.com\n[blog post]: http://codeascraft.etsy.com/2011/02/15/measure-anything-measure-everything/\n[node]: http://nodejs.org\n[nodemods]: http://nodejs.org/api/modules.html\n[udp]: http://en.wikipedia.org/wiki/User_Datagram_Protocol\n\n\nContributors\n-----------------\n\nIn lieu of a list of contributors, check out the commit history for the project:\nhttps://github.com/etsy/statsd/graphs/contributors\n",
  "_id": "statsd@0.5.0",
  "dist": {
    "shasum": "7e38fce97aeba140b797a375dfc293d0624d8e7f"
  },
  "_from": "statsd"
}
